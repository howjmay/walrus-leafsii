#[test_only]
module leafsii::test_cr_levels {
    use sui::clock::{Self, Clock};
    use sui::coin::{Self, Coin};
    use sui::test_scenario::{Self as ts, Scenario};
    
    use math::math;
    use oracle::oracle::{Self, MockOracle};
    use leafsii::leafsii::{Self, Protocol};
    use leafsii::stability_pool::{Self, StabilityPool, SPPosition};
    use sui_system::staking_pool::FungibleStakedSui;
    use sui::sui::SUI;

    // Test asset types
    public struct TEST_FTOKEN has drop {}
    public struct TEST_XTOKEN has drop {}

    const INITIAL_PRICE_E6: u64 = 2_000_000; // $2.00
    const DEPOSIT_AMOUNT: u64 = 1_000_000; // 1 TEST_RESERVE
    const SCALE_FACTOR: u64 = 1_000_000;
    
    // CR Thresholds (from leafsii.move:34-37)
    const CR_T_L1: u64 = 1_306_000;  // 1.306 * 1e6 - high CR
    const CR_T_L2: u64 = 1_206_000;  // 1.206 * 1e6 - marginal above min
    const CR_T_L3: u64 = 1_144_000;  // 1.144 * 1e6 - at min boundary

    // Test helper to create protocol with returned objects properly handled
    fun setup_protocol_with_sp(scenario: &mut Scenario, clock: &Clock): (Coin<TEST_FTOKEN>, Coin<TEST_XTOKEN>, leafsii::AdminCap, stability_pool::StabilityPoolAdminCap) {
        let ctx = ts::ctx(scenario);
        
        // Create stability pool first
        let sp_cap = stability_pool::create_stability_pool<TEST_RESERVE, TEST_FTOKEN>(ctx);
        
        ts::next_tx(scenario, @0x1);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(scenario);
        
        // Create protocol with pool reference
        let stable_treasury_cap = coin::create_treasury_cap_for_testing<TEST_FTOKEN>(ts::ctx(scenario));
        let leverage_treasury_cap = coin::create_treasury_cap_for_testing<TEST_XTOKEN>(ts::ctx(scenario));
        let reserve_coin = coin::mint_for_testing<SUI>(DEPOSIT_AMOUNT, ts::ctx(scenario));
        
        // Bind pool to protocol
        let protocol_id = sui::object::id_from_address(@0x123);
        stability_pool::bind_pool_to_protocol(&mut pool, &sp_cap, protocol_id);

        let (f_coin, x_coin, admin_cap) = leafsii::init_protocol<TEST_FTOKEN, TEST_XTOKEN>(
            stable_treasury_cap,
            leverage_treasury_cap,
            INITIAL_PRICE_E6,
            reserve_coin,
            &mut pool,
            &sp_cap,
            clock,
            ts::ctx(scenario)
        );

        ts::return_shared(pool);
        (f_coin, x_coin, admin_cap, sp_cap)
    }

    fun setup_test(): (Scenario, Clock, MockOracle<SUI>) {
        let mut scenario = ts::begin(@0x1);
        let ctx = ts::ctx(&mut scenario);
        
        let clock = clock::create_for_testing(ctx);
        let oracle = oracle::create_mock_oracle<TEST_RESERVE>(INITIAL_PRICE_E6, &clock, ctx);
        
        (scenario, clock, oracle)
    }

    // Helper to push CR to a specific level by adjusting SP obligations
    fun push_cr_to_level(
        protocol: &Protocol<TEST_FTOKEN, TEST_XTOKEN>,
        pool: &mut StabilityPool<FungibleStakedSui, TEST_FTOKEN>,
        target_level: u8,
        ctx: &mut TxContext
    ): SPPosition<FungibleStakedSui, TEST_FTOKEN> {
        // Create SP position and deposit to enable rebalancing
        let mut position = stability_pool::create_position<TEST_RESERVE, TEST_FTOKEN>(ctx);
        let f_token = coin::mint_for_testing<TEST_FTOKEN>(3_000_000, ctx); // Ample fToken
        stability_pool::deposit_f(pool, &mut position, f_token, ctx);
        
        // Calculate current state
        let current_reserve = leafsii::get_reserve_balance(protocol);
        let (current_nf, _, _, _, _, _, _, _) = leafsii::get_protocol_state(protocol);
        
        if (target_level == 1) {
            // L1: High CR - no additional obligations needed, should already be in L1
        } else if (target_level == 2) {
            // L2: Need CR between 1.206 and 1.306
            // Target CR = 1.25, so reserve_net_usd / (nf * pf) = 1.25
            // reserve_net_usd = nf * pf * 1.25 = nf * 1_000_000 * 1.25
            let target_cr = 1_250_000;
            let target_reserve_net_usd = math::mul_div(current_nf, target_cr, SCALE_FACTOR);
            let current_reserve_usd = math::mul_div(current_reserve, INITIAL_PRICE_E6, SCALE_FACTOR);
            if (current_reserve_usd > target_reserve_net_usd) {
                let needed_obligation_usd = current_reserve_usd - target_reserve_net_usd;
                let needed_obligation_r = math::mul_div(needed_obligation_usd, SCALE_FACTOR, INITIAL_PRICE_E6);
                let pool_protocol_id = stability_pool::pool_id(pool);
                let dummy_cap = stability_pool::create_dummy_capability_with_id(pool_protocol_id, ctx);
                let (_burned, _indexed) = stability_pool::sp_controller_rebalance(pool, &dummy_cap, 800_000, needed_obligation_r, ctx);
                stability_pool::destroy_capability(dummy_cap);
            };
        } else if (target_level == 3) {
            // L3: Need CR between 1.144 and 1.206
            let target_cr = 1_175_000; // 1.175
            let target_reserve_net_usd = math::mul_div(current_nf, target_cr, SCALE_FACTOR);
            let current_reserve_usd = math::mul_div(current_reserve, INITIAL_PRICE_E6, SCALE_FACTOR);
            if (current_reserve_usd > target_reserve_net_usd) {
                let needed_obligation_usd = current_reserve_usd - target_reserve_net_usd;
                let needed_obligation_r = math::mul_div(needed_obligation_usd, SCALE_FACTOR, INITIAL_PRICE_E6);
                let pool_protocol_id = stability_pool::pool_id(pool);
                let dummy_cap = stability_pool::create_dummy_capability_with_id(pool_protocol_id, ctx);
                let (_burned, _indexed) = stability_pool::sp_controller_rebalance(pool, &dummy_cap, 1_000_000, needed_obligation_r, ctx);
                stability_pool::destroy_capability(dummy_cap);
            };
        } else if (target_level == 4) {
            // L4: Need CR between 1.050 and 1.144
            let target_cr = 1_100_000; // 1.1
            let target_reserve_net_usd = math::mul_div(current_nf, target_cr, SCALE_FACTOR);
            let current_reserve_usd = math::mul_div(current_reserve, INITIAL_PRICE_E6, SCALE_FACTOR);
            if (current_reserve_usd > target_reserve_net_usd) {
                let needed_obligation_usd = current_reserve_usd - target_reserve_net_usd;
                let needed_obligation_r = math::mul_div(needed_obligation_usd, SCALE_FACTOR, INITIAL_PRICE_E6);
                let pool_protocol_id = stability_pool::pool_id(pool);
                let dummy_cap = stability_pool::create_dummy_capability_with_id(pool_protocol_id, ctx);
                let (_burned, _indexed) = stability_pool::sp_controller_rebalance(pool, &dummy_cap, 1_200_000, needed_obligation_r, ctx);
                stability_pool::destroy_capability(dummy_cap);
            };
        };
        
        position
    }

    #[test]
    fun test_cr_level_1_high_cr() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);

        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp

        // Update oracle
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);

        // Verify we're in L1 initially
        let cr = leafsii::collateral_ratio(&protocol, &pool);
        let level = leafsii::current_level(&protocol, &pool);

        // Initial CR should be high (reserve_usd / nf_usd = 2.0M / 1.0M = 2.0)
        assert!(cr >= CR_T_L1, 0);
        assert!(level == 0, 1); // Level 0 = Normal mode

        // L1 should allow minting
        let reserve_coin = coin::mint_for_testing<SUI>(500_000, ts::ctx(&mut scenario));
        let minted_f = leafsii::mint_f(&mut protocol, &pool, reserve_coin, ts::ctx(&mut scenario));

        // Verify mint succeeded and CR still >= L1 threshold
        let new_cr = leafsii::collateral_ratio(&protocol, &pool);
        assert!(new_cr >= CR_T_L1, 2);

        // L1 should allow redemption
        let redeem_f = coin::mint_for_testing<TEST_FTOKEN>(500_000, ts::ctx(&mut scenario));
        let redeemed_reserve = leafsii::redeem_f(&mut protocol, &pool, redeem_f, ts::ctx(&mut scenario));

        // Cleanup
        transfer::public_transfer(minted_f, @0x1);
        transfer::public_transfer(redeemed_reserve, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    /// fToken minting should be blocked at L1 due to fee policy
    #[expected_failure(abort_code = leafsii::E_ACTION_BLOCKED_BY_CR)]
    fun test_cr_level_2_ftoken_mint_blocked() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L2
        let position = push_cr_to_level(&protocol, &mut pool, 2, ts::ctx(&mut scenario));
        
        let cr = leafsii::collateral_ratio(&protocol, &pool);
        let level = leafsii::current_level(&protocol, &pool);
        
        // Should be in L1: CR >= L2 but < L1  
        assert!(cr >= CR_T_L2 && cr < CR_T_L1, 0);
        assert!(level == 1, 1); // Level 1 = L1 Stability mode
        
        // Try to mint fTokens - should be blocked at L1 due to fee policy
        let reserve_coin = coin::mint_for_testing<SUI>(200_000, ts::ctx(&mut scenario));
        let minted_f = leafsii::mint_f(&mut protocol, &pool, reserve_coin, ts::ctx(&mut scenario));
        
        // Cleanup (should not reach here due to expected failure)
        transfer::public_transfer(minted_f, @0x1);
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_cr_level_3_at_min_boundary() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L3
        let position = push_cr_to_level(&protocol, &mut pool, 3, ts::ctx(&mut scenario));
        
        let cr = leafsii::collateral_ratio(&protocol, &pool);
        let level = leafsii::current_level(&protocol, &pool);
        
        // Should be in L2: CR >= L3 but < L2
        assert!(cr >= CR_T_L3 && cr < CR_T_L2, 0);
        assert!(level == 2, 1); // Level 2 = L2 User Rebalance mode
        
        // L2 should still allow user actions - no blocking at L2
        
        // But L3 should allow protocol rebalancing - check if improvement occurs
        let initial_cr = leafsii::collateral_ratio(&protocol, &pool);
        let target_cr = 1_300_000; // Target 1.3 CR
        leafsii::protocol_rebalance_l3_to_target(&mut protocol, &mut pool, &sp_cap, target_cr, &admin_cap, ts::ctx(&mut scenario));
        
        // After rebalancing, CR should improve or stay the same if already at target
        let new_cr = leafsii::collateral_ratio(&protocol, &pool);
        assert!(new_cr >= initial_cr, 2); // Check for improvement or no degradation
        
        // Cleanup
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_cr_level_4_below_min() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L4 (below minimum)
        let position = push_cr_to_level(&protocol, &mut pool, 4, ts::ctx(&mut scenario));
        
        let cr = leafsii::collateral_ratio(&protocol, &pool);
        let level = leafsii::current_level(&protocol, &pool);
        
        // Should be in L3: below L3 threshold
        assert!(cr < CR_T_L3, 0);
        assert!(level == 3, 1); // Level 3 = L3 Protocol Rebalance mode
        
        // At L3, protocol should trigger aggressive rebalancing
        let target_cr = 1_200_000; // Target back to L1
        leafsii::protocol_rebalance_l3_to_target(&mut protocol, &mut pool, &sp_cap, target_cr, &admin_cap, ts::ctx(&mut scenario));
        
        // Verify improvement (may be limited based on available SP funds)
        let new_cr = leafsii::collateral_ratio(&protocol, &pool);
        let new_level = leafsii::current_level(&protocol, &pool);
        assert!(new_cr >= cr, 2); // CR should improve or stay same
        assert!(new_level <= 3, 3); // Level should not worsen
        
        // Cleanup
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    #[expected_failure(abort_code = leafsii::E_ACTION_BLOCKED_BY_CR)] // E_ACTION_BLOCKED_BY_CR
    fun test_mint_f_blocked_at_l1() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, _sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L1
        let position = push_cr_to_level(&protocol, &mut pool, 2, ts::ctx(&mut scenario));
        
        // Verify we're in L1 (level 1)
        let level = leafsii::current_level(&protocol, &pool);
        assert!(level == 1, 0);

        // Transfer sp_cap before expected failure to avoid drop issues
        transfer::public_transfer(_sp_cap, @0x1);

        // This should fail with E_ACTION_BLOCKED_BY_CR (code 6)
        let reserve_coin = coin::mint_for_testing<SUI>(100_000, ts::ctx(&mut scenario));
        let _minted_f = leafsii::mint_f(&mut protocol, &pool, reserve_coin, ts::ctx(&mut scenario));
        
        // Cleanup (won't reach here due to expected failure)
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        transfer::public_transfer(_minted_f, @0x1);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_mint_x_allowed_at_l1() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L1
        let position = push_cr_to_level(&protocol, &mut pool, 2, ts::ctx(&mut scenario));
        
        let level = leafsii::current_level(&protocol, &pool);
        assert!(level == 1, 0);
        
        // This should succeed in L1 - xToken mint is allowed
        let reserve_coin = coin::mint_for_testing<SUI>(100_000, ts::ctx(&mut scenario));
        let _minted_x = leafsii::mint_x(&mut protocol, &pool, reserve_coin, ts::ctx(&mut scenario));
        
        // Cleanup (won't reach here)
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        transfer::public_transfer(_minted_x, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_redeem_f_allowed_at_l1() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L1
        let position = push_cr_to_level(&protocol, &mut pool, 2, ts::ctx(&mut scenario));
        
        let level = leafsii::current_level(&protocol, &pool);
        assert!(level == 1, 0);
        
        // This should succeed - fToken redeem is allowed in L1 with 0% fee
        let f_coin = coin::mint_for_testing<TEST_FTOKEN>(100_000, ts::ctx(&mut scenario));
        let _redeemed = leafsii::redeem_f(&mut protocol, &pool, f_coin, ts::ctx(&mut scenario));
        
        // Cleanup (won't reach here)
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        transfer::public_transfer(_redeemed, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_redeem_x_allowed_at_l1() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let mut pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Push CR to L1
        let position = push_cr_to_level(&protocol, &mut pool, 2, ts::ctx(&mut scenario));
        
        let level = leafsii::current_level(&protocol, &pool);
        assert!(level == 1, 0);
        
        // This should succeed - xToken redeem allowed in L1 with increased fee
        let x_coin = coin::mint_for_testing<TEST_XTOKEN>(100_000, ts::ctx(&mut scenario));
        let _redeemed = leafsii::redeem_x(&mut protocol, &pool, x_coin, ts::ctx(&mut scenario));
        
        // Cleanup (won't reach here)
        transfer::public_transfer(position, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        transfer::public_transfer(_redeemed, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }

    #[test]
    fun test_cr_calculation_accuracy() {
        let (mut scenario, clock, oracle) = setup_test();
        let (init_f, init_x, admin_cap, sp_cap) = setup_protocol_with_sp(&mut scenario, &clock);
        
        ts::next_tx(&mut scenario, @0x1);
        let mut protocol = ts::take_shared<Protocol<TEST_FTOKEN, TEST_XTOKEN>>(&scenario);
        let pool = ts::take_shared<StabilityPool<FungibleStakedSui, TEST_FTOKEN>>(&scenario);
        // Using admin_cap from setup_protocol_with_sp
        
        leafsii::update_from_oracle(&mut protocol, &oracle, &clock, &admin_cap);
        
        // Test initial CR calculation
        // Reserve: 1.0 R at $2.00 = $2.0M USD
        // F tokens: 1.0 F at $1.00 = $1.0M USD  
        // Expected CR = 2.0M / 1.0M = 2.0 = 2_000_000 in scaled units
        let cr = leafsii::collateral_ratio(&protocol, &pool);
        assert!(cr == 2_000_000, 0);
        
        // Add more F tokens and verify CR updates
        let reserve_coin = coin::mint_for_testing<SUI>(500_000, ts::ctx(&mut scenario)); // +0.5 R
        let minted_f = leafsii::mint_f(&mut protocol, &pool, reserve_coin, ts::ctx(&mut scenario)); // Should mint ~1.0 F
        
        // New state with fee policy: ~1.4975 R at $2.00 = ~$2.995M USD; ~1.995 F at $1.00 = ~$1.995M USD
        // Expected CR = ~2.995M / ~1.995M = ~1.501 (actual: 1,501,253 due to fee rounding)
        let new_cr = leafsii::collateral_ratio(&protocol, &pool);
        assert!(new_cr == 1_501_253, 1);
        
        // Verify level calculation  
        let level = leafsii::current_level(&protocol, &pool);
        assert!(level == 0, 2); // 1.5 >= CR_T_L1 (1.306) = Normal mode
        
        // Cleanup
        transfer::public_transfer(minted_f, @0x1);
        transfer::public_transfer(init_f, @0x1);
        transfer::public_transfer(init_x, @0x1);
        ts::return_shared(protocol);
        transfer::public_transfer(admin_cap, @0x1);
        stability_pool::destroy_capability(sp_cap);
        ts::return_shared(pool);
        transfer::public_transfer(oracle, @0x1);
        clock::destroy_for_testing(clock);
        ts::end(scenario);
    }
}